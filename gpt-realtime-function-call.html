<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Azure OpenAI Realtime Session</title>
</head>
<body>
    <h1>Azure OpenAI Realtime Session</h1>
    <p>WARNING: Don't use this code sample in production with the API key hardcoded. Use a protected backend service to call the sessions API and generate the ephemeral key. Then return the ephemeral key to the client.</p>
    <button onclick="StartSession()">Start Session</button>

    <!-- Log container for API messages -->
    <div id="logContainer"></div> 

    <script>

        // Make sure the WebRTC URL region matches the region of your Azure OpenAI resource.
        // For example, if your Azure OpenAI resource is in the swedencentral region,
        // the WebRTC URL should be https://swedencentral.realtimeapi-preview.ai.azure.com/v1/realtimertc.
        // If your Azure OpenAI resource is in the eastus2 region, the WebRTC URL should be https://eastus2.realtimeapi-preview.ai.azure.com/v1/realtimertc.
        const WEBRTC_URL= "https://eastus2.realtimeapi-preview.ai.azure.com/v1/realtimertc"

        // The SESSIONS_URL includes the Azure OpenAI resource URL,
        // deployment name, the /realtime/sessions path, and the API version.
        // The Azure OpenAI resource region isn't part of the SESSIONS_URL.
		//https://quanshiextra1.openai.azure.com/openai/realtimeapi/sessions?api-version=2025-04-01-preview
        const SESSIONS_URL="https://quanshiextra1.openai.azure.com/openai/realtimeapi/sessions?api-version=2025-04-01-preview"

        // The API key of the Azure OpenAI resource.
        const API_KEY = "2ljGZV5Wr3yyaqdlosOHBu23KsUFRsWuJ1tcDbWuQbVh5KBMlsn4JQQJ99BDACHYHv6XJ3w3AAABACOGutIC"; 

        // The deployment name might not be the same as the model name.
        const DEPLOYMENT = "meeting-gpt-realtime"
		const VOICE = "sage"

        async function StartSession() {
            try {

                // WARNING: Don't use this code sample in production
                // with the API key hardcoded. 
                // Use a protected backend service to call the 
                // sessions API and generate the ephemeral key.
                // Then return the ephemeral key to the client.

                const response = await fetch(SESSIONS_URL, {
                    method: "POST",
                    headers: {
                        //"Authorization": `Bearer ${ACCESS_TOKEN}`,
                        "api-key": API_KEY,
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify({
                        model: DEPLOYMENT,
                        voice: VOICE
                    })
                });

                if (!response.ok) {
                    throw new Error(`API request failed`);
                }

                const data = await response.json();

                const sessionId = data.id;
                const ephemeralKey = data.client_secret?.value; 
                console.error("Ephemeral key:", ephemeralKey);

                // Mask the ephemeral key in the log message.
                logMessage("Ephemeral Key Received: " + "***");
		        logMessage("WebRTC Session Id = " + sessionId );

                // Set up the WebRTC connection using the ephemeral key.
                init(ephemeralKey); 

            } catch (error) {
                console.error("Error fetching ephemeral key:", error);
                logMessage("Error fetching ephemeral key: " + error.message);
            }
        }
		
		function createMeeting(args) {
			alert("触发了我配置的工具函数 【createMeeting】！您预约的会议[" + args.title + "]在： " + args.start_time + " 召开，持续时长：" + args.duration + "分钟");
			return true;
		}

        async function init(ephemeralKey) {

            let peerConnection = new RTCPeerConnection();

            // Set up to play remote audio from the model.
            const audioElement = document.createElement('audio');
            audioElement.autoplay = true;
            document.body.appendChild(audioElement);

            peerConnection.ontrack = (event) => {
                audioElement.srcObject = event.streams[0];
            };

            // Set up data channel for sending and receiving events
            const clientMedia = await navigator.mediaDevices.getUserMedia({ audio: true });
            const audioTrack = clientMedia.getAudioTracks()[0];
            peerConnection.addTrack(audioTrack);

            const dataChannel = peerConnection.createDataChannel('realtime-channel');

            dataChannel.addEventListener('open', () => {
                logMessage('Data channel is open');
                updateSession(dataChannel);
				responseCreate(dataChannel);
				//conversationCreate(dataChannel);
            });

            dataChannel.addEventListener('message', (event) => {
                const realtimeEvent = JSON.parse(event.data); 
                console.log(realtimeEvent); 
                logMessage("Received server event: " + JSON.stringify(realtimeEvent, null, 2));
                if (realtimeEvent.type === "session.update") {
                    const instructions = realtimeEvent.session.instructions;
                    logMessage("Instructions: " + instructions);
                } else if (realtimeEvent.type === "session.error") {
                    logMessage("Error: " + realtimeEvent.error.message);
                } else if (realtimeEvent.type === "session.end") {
                    logMessage("Session ended.");
                } else if (realtimeEvent.type === "response.output_item.done") {
					const item = realtimeEvent.item;
					if (item.type == "function_call") {
						try {
							const args = JSON.parse(item.arguments);
							if (item.name == "createMeeting") {
								//conversationCreate(dataChannel, "请回复：好的！正在帮您预约会议！");
								//responseCreate(dataChannel);
								
								let result = createMeeting(args);
								if (result) {
									/*const event = {
										"type": "conversation.item.create",
										"item": {
											"type": "function_call_output",
											"call_id": item["call_id"],
											"output": "请回复：您的会议已经预约成功！"
										}
									};
									dataChannel.send(JSON.stringify(event));*/

									conversationCreate(dataChannel, "到这边说明会议已经创建成功了！请进行相应回复");
									responseCreate(dataChannel);
								}
							}
						} catch(e) {
							logMessage("createMeeting error: " + e);
							return;
						}
					}
				}
            });

            dataChannel.addEventListener('close', () => {
                logMessage('Data channel is closed');
            });

	          // Start the session using the Session Description Protocol (SDP)
            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);

            const sdpResponse = await fetch(`${WEBRTC_URL}?model=${DEPLOYMENT}`, {
                method: "POST",
                body: offer.sdp,
                headers: {
                    Authorization: `Bearer ${ephemeralKey}`,
                    "Content-Type": "application/sdp",
                },
            });

            const answer = { type: "answer", sdp: await sdpResponse.text() };
            await peerConnection.setRemoteDescription(answer);

            const button = document.createElement('button');
            button.innerText = 'Close Session';
            button.onclick = stopSession;
            document.body.appendChild(button);

            // Send a client event to update the session
            function updateSession(dataChannel) {
                const event = {
                    type: "session.update",
                    session: {
                        instructions: "你是一名视频会议助理，请用亲切的语气为客户提供服务。你的开场招呼语是：我是您的会议助理小爱！请问有什么能够帮助您的么？\n##注意：\n#你目前只能提供创建会议的服务，并且需要客户提供开始时间、持续时长、会议名称。\n#在创建会议前，请再确认一下客户提供的信息是否修改，不需要则继续执行tools。", // "你是一名专业耳机导购同时也是一名！请用亲切的语气为顾客介绍产品。你的开场招呼语是：我是您的助理小爱！请问有什么能够帮助您的么？"
						"turn_detection": {
						  "type": "server_vad",
						  "threshold": 0.5,
						  "prefix_padding_ms": 300,
						  "silence_duration_ms": 200,
						  "create_response": true
						},
						tools: [
							/*{
								"type": "mcp",
								"server_label": "github",
								"server_url": "https://contoso.com/Azure/azure-rest-api-specs",
								"require_approval": "never"
							},*/
							{
							  "type": "function",
							  "name": "queryKnowledgeBase",
							  "description": "查询内部知识库，获取与用户问题相关的信息。",
							  "parameters": {
								"type": "object",
								"properties": {
								  "question": {
									"type": "string",
									"description": "用户的问题"
								  }
								},
								"required": ["question"]
							  }
							},
							{
							  "type": "function",
							  "name": "createMeeting",
							  "description": "创建一场指定开始时间、会议时长以及名称的会议，用于后续开视频会议。",
							  "parameters": {
								"type": "object",
								"properties": {
								  "start_time": {
									"type": "string",
									"description": "会议的开始时间，格式为：（年-月-日 小时:分钟:00） 例：2025-09-09 15:33:00"
								  },
								  "duration": {
									"type": "integer",
									"description": "会议的时长，格式为：数字（分钟） 例：120"
								  },
								  "title": {
									"type": "string",
									"description": "会议名称，默认名称：我的会议"
								  },
								},
								"required": ["start_time", "duration", "title"]
							  }
							}
						],
						tool_choice: "auto"
                    }
                };
                dataChannel.send(JSON.stringify(event));
                logMessage("Sent client event: " + JSON.stringify(event, null, 2));
            }
			
            function conversationCreate(dataChannel, str) {
                const event = {
                    type: "conversation.item.create",
					item: {
						type: "message",
						role: "user",
						content: [{ type: "input_text", text: str}],
					}
                };
                dataChannel.send(JSON.stringify(event));
                logMessage("Sent client event: " + JSON.stringify(event, null, 2));
            }
			
            function responseCreate(dataChannel) {
                const event = {
                    type: "response.create"
                };
                dataChannel.send(JSON.stringify(event));
                logMessage("Sent client event: " + JSON.stringify(event, null, 2));
            }

            function stopSession() {
                if (dataChannel) dataChannel.close();
                if (peerConnection) peerConnection.close();
                peerConnection = null;
                logMessage("Session closed.");
            }

        }

        function logMessage(message) {
            const logContainer = document.getElementById("logContainer");
            const p = document.createElement("p");
            p.textContent = message;
            logContainer.appendChild(p);
			
			window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });
        }
    </script>
</body>
</html>